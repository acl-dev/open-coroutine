# open-coroutine

## 目录

- [诞生之因](#诞生之因)
- [三顾协程](#三顾协程)
- [语言选择](#语言选择)
- [架构简析](#架构简析)

## 诞生之因

2020年我大学毕业，入职了W公司，由于内部系统不时出现线程池打满的情况，再加上TL读过[《Java线程池实现原理及其在美团业务中的实践》](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)，我们决定构建自己的动态线程池，从结果来看，效果不错：

![](img/begin.jpg)

但是这没有从根本上解决问题。

众所周知，只要线程数超过CPU核心数就会带来额外的线程上下文切换开销，线程数越多，线程上下文切换开销越大。

对于CPU密集型任务，只需保证线程数等于CPU核心数(以下简称为`thread-per-core`)，即可保证最优性能，而对于IO密集型任务，由于任务几乎必定阻塞住线程，线程上下文切换开销一般小于阻塞开销，但当线程数过大时，线程上下文切换开销就会大于阻塞开销了。

动态线程池的本质就是通过调整线程数，尽可能地让线程上下文切换开销小于阻塞开销。由于这个是人工保证的，那么必然保证不了。

![](img/run.jpg)

那么有没有一种技术能够在保证`thread-per-core`的前提下，执行IO密集型任务性能不输多线程呢？

答案是NIO，但仍存在一些限制或者不友好的地方：

1. NIO API使用起来较为复杂；
2. `Thread.sleep()`等阻塞调用会阻塞线程；
3. 无法实现任务间的公平调度(假设CPU时间片为1s，有100个任务，公平调度指每个任务都能公平地占用到10ms的时间片，而整个1s的大时间片不yield)；

1还可以克服，2和3是硬伤，其实如果能够实现3，RPC框架们也不用搞太多线程，只要`thread-per-core`即可。

有没有能够在保证`thread-per-core`、执行IO密集型任务性能不输多线程的前提下，使用还十分简单的技术呢？

`协程`慢慢进入了我的视野。

## 三顾协程

一开始玩协程，出于学习成本的考虑，首先选择的是`kotlin`，但当我发现kotlin的协程使用`Thread.sleep()`会阻塞线程后，果断把方向调整为`golang`，大概2周后：

![](img/good.jpeg)

协程技术哪家强，编程语言找golang。

然而随着更深入的学习，我发现几个`goroutine`的不足：

1. 不是严格的`thread-per-core`，`goroutine`运行时也是由线程池来支撑的，而这个线程池的最大线程为`256`，这个数字可比`thread-per-core`的线程数大得多；
2. 抢占调度会打断正在运行的系统调用，如果这个系统调用需要很长时间才能完成，显然会被打断多次，整体性能反而降低；
3. `goroutine`的确做到了高性能，但离极限性能有明显差距(c/c++协程库的性能甚至到了goroutine的1.5倍)；

带着遗憾，我开始继续研究c/c++的协程库，发现它们要么是只做了hook(后面再详细解释)，要么只做了任务窃取，而最令人失望的是：没有一个协程库实现了`抢占调度`。

没办法，看样子只能自己干了。

![](img/just_do_it.jpg)

## 语言选择

既然决定造轮子，那么需要选择开发轮子的语言。

之前研究c协程库时，有看到大佬已经尝试过用c写动态链接库，然后java通过jni去调这种方式，最终失败了，具体原因得深入JVM源码才能得知，对鄙人来说太复杂，放弃了，因此排除掉java/kotlin等java字节码语言。

显然，用golang再去实现一个goroutine，且不说其复杂程度完全不亚于深入JVM源码，而且即使真的做出来，也不可能有人愿意在生产环境使用，因此排除golang。

到目前为止还剩下c/c++/rust 3位选手。

c语言由于其语法古老，需要编写巨量代码，对个人开发者不太友好，排除。

c++使用还算方便，表达力强，一开始咱就打算用c++写的，但是写着写着发现几个问题：

1. 需要不停地写cmake，告诉系统怎么编译它，有些麻烦；
2. 如果要用别人写的类库，把代码拉下来，放到自己项目里，然后需要耗费大量时间来通过编译。如果别人依赖的库没有其他依赖还好，一旦有其他依赖，那么它依赖的依赖，也得按照刚才说的步骤处理，这就十分麻烦了。

![](img/what_else_can_I_say.jpg)

![](img/rust.jpeg)

## 架构简析

以下都是todo

## 底层选型

## Scheduler

## 时间轮

## 任务窃取

## 抢占调度

## EventLoop

## JoinHandle

## 系统调用钩子

## 再次封装

## 极简属性宏

## 发布之后
