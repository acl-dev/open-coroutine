use crate::arch::Detour;
use crate::error::Result;
use crate::{Function, HookableWith};
use std::marker::PhantomData;

/// A type-safe detour.
///
/// Due to being generated by a macro, the `GenericDetour::call` method is not
/// exposed in the documentation.  
/// It accepts the same arguments as `T`, and shares its result type:
///
/// ```c
/// /// Calls the original function regardless of whether it's hooked or not.
/// fn call(&self, T::Arguments) -> T::Output
/// ```
#[derive(Debug)]
pub struct GenericDetour<T: Function> {
    phantom: PhantomData<T>,
    detour: Detour,
}

impl<T: Function> GenericDetour<T> {
    /// Create a new hook given a target function and a compatible detour
    /// function.
    pub unsafe fn new<D>(target: T, detour: D) -> Result<Self>
    where
        T: HookableWith<D>,
        D: Function,
    {
        Detour::new(target.to_ptr(), detour.to_ptr()).map(|detour| GenericDetour {
            phantom: PhantomData,
            detour,
        })
    }

    /// Enables the detour.
    pub unsafe fn enable(&self) -> Result<()> {
        self.detour.enable()
    }

    /// Disables the detour.
    pub unsafe fn disable(&self) -> Result<()> {
        self.detour.disable()
    }

    /// Returns whether the detour is enabled or not.
    pub fn is_enabled(&self) -> bool {
        self.detour.is_enabled()
    }

    /// Returns a reference to the generated trampoline.
    pub(crate) fn trampoline(&self) -> &() {
        self.detour.trampoline()
    }
}

unsafe impl<T: Function> Send for GenericDetour<T> {}
unsafe impl<T: Function> Sync for GenericDetour<T> {}
